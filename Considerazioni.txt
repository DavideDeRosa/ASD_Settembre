Considerazioni finali su tutti gli esercizi.
Schema di base per ogni esercizio:
    -Mia implementazione
    -Altre possibili implementazioni
    -Altro

-Esercizio1(hash table custom):
    Ho scelto di implementare la struttura dati richiesta attraverso l'utilizzo di una Tabella Hash con Liste di Trabocco. Avendo una 
    distribuzione uniforme delle chiavi generate in maniera casuale possiamo suddividere la nostra tabella in intervalli uniformi.
    La funzione di hashing ci permette di trovare la posizione nella quale inserire la chiave, puntando all'intervallo corretto.
    Avendo una implementazione con liste di trabocco, ogni intervallo avra' una lista associata. Per garantire, a livello teorico,
    il numero di accessi medi 'T', possiamo utilizzare la formula (1 + fattore di carico) = T. In questo modo, troviamo il fattore di
    carico per ogni 'T' data in input. Viene poi effettuata una suddivisione in intervalli uniformi della struttura. Passando al lato
    'sperimentale', andiamo a calcolare il numero di accessi medi alla struttura attraverso contatori, che ci permettono di verificare
    la correttezza della struttura, rispettando le richieste della traccia. Infine viene stampato in console l'NMA inerente all'operazione
    di verifica effettuata sulle 300 chiavi generate in maniera casuale.

-Esercizio2(array):
    Ho scelto di implementare il tutto attraverso l'utilizzo di un semplice Array di "Coppia", classe creata appositamente per mantenere
    i dati inerenti alla coppia. Una volta caricate le diverse coppie dal file di input, viene mostrato all'utente un elenco di funzioni.
    La prima funzione richiede tre valori (a, b, s), che permettono successivamente di richiamare il metodo "find()". 
    Il metodo find() scorre tutto l'Array per stampare ogni coppia che abbia il valore della chiave compreso tra a e b e la lunghezza
    della stringa minore o uguale a s. Il costo computazionale di questo metodo è O(n), dovendo scorrere tutti gli elementi dell'Array.
    La seconda funzione richiede un valore (c), che permette successivamente di richiamare il metodo "print()".
    Il metodo print() scorre tutto l'Array per stamapre ogni coppia che abbia il valore della chiave maggiore o uguale a c.
    Il costo computazionale di questo metodo è O(n), dovendo scorrere tutti gli elementi dell'Array.
    Per concludere, la funzione che carica tutte le coppie dal file di input ha costo computazionale O(n).
    
    Il costo computazionale della soluzione è quindi O(n).
    
    Altre possibili implementazioni prevedevano l'utilizzo di ArrayList, MinHeap o HashMap, con costi computazionali simili e in
    alcuni casi maggiori.

-Esercizio3(basato su Ricerca Binaria):
    Ho scelto di implementare il tutto attraverso l'utilizzo di un algoritmo basato sul Binary Search con la tecnica del Divide-et-Impera,
    come richiesto dalla traccia. La tecnica del Divide-et-Impera si basa su tre passaggi progressivi:
        -DIVIDE: si divide il problema in sottoproblemi.
        -IMPERA: si risolvono i sottoproblemi in maniera ricorsiva.
        -COMBINA: si uniscono le soluzioni dei sottoproblemi per costruire la soluzione del problema originario.

    Nel nostro caso specifico la suddivisione in sottoproblemi riguarda la suddivisione dell'Array in un Array più piccolo, sul quale
    richiamiamo la funzione ricorsiva. Una volta risolti tutti i sottoproblemi, andiamo a sommare il numero dei dipendenti promossi
    ottenuti tramite le diverse chiamate ricorsive.

    Il costo computazionale del metodo "contaPromossi()" va calcolato attraverso l'utilizzo del Master Theorem.
    L'equazione di ricorrenza di questo metodo è T(n) = T(n/2) + O(1), che in base al Master Theorem ha soluzione T(n) = O(log n).

    Un altra possibile implementazione, quella iterativa, non avrebbe soddisfatto la richiesta della traccia di utilizzare la 
    tecnica del Divide-et-Impera, pertanto è stata scartata a priori.

-Esercizio4(Bellman-Ford):
    ciao

-Esercizio5(Floyd-Warshall):
    ciao

--------------------------------------------------------------------------------------------------------------------------------------
Versioni vecchie o sbagliate:

-Esercizio2(old, sbagliato il discorso sulla mappa):
    Ho scelto di implementare il tutto attraverso l'utilizzo di un ArrayList di "Coppia", classe creata appositamente per mantenere
    i dati inerenti alla coppia. Una volta caricate le diverse coppie dal file di input, viene mostrato all'utente un elenco di funzioni.
    La prima funzione richiede tre valori (a, b, s), che permettono successivamente di richiamare il metodo "find()". 
    Il metodo find() scorre tutta la lista per stampare ogni coppia che abbia il valore della chiave compreso tra a e b e la lunghezza
    della stringa minore o uguale a s. Il costo computazionale di questo metodo è O(n), dovendo scorrere tutti gli elementi della lista.
    La seconda funzione richiede un valore (c), che permette successivamente di richiamare il metodo "print()".
    Il metodo print() scorre tutta la lista per stamapre ogni coppia che abbia il valore della chiave maggiore o uguale a c.
    Il costo computazionale di questo metodo è O(n), dovendo scorrere tutti gli elementi della lista.
    Per concludere, la funzione che carica tutte le coppie dal file di input ha costo computazionale O(n).
    
    Il costo computazionale della soluzione è quindi O(n).

    Un altra possibile implementazione prevedeva l'utilizzo di una HashMap al posto dell'ArrayList. In questo caso l'implementazione
    avrebbe visto una HashMap<Integer, List<String>>, ammettendo ovviamente chiavi uguali con stringhe differenti.
    Questo utilizzo avrebbe comportato un costo minore per il metodo "print()", riducendo il costo ad O(1) al posto di O(n) per il
    metodo specifico, specialmente quando il numero di coppie è molto grande.
    Non sarebbe però variato il costo computazionale finale (sempre O(n)), che viene influenzato principalmente dall'operazione di 
    caricamento delle coppie dal file.

-Esercizio2(ArrayList):
    Ho scelto di implementare il tutto attraverso l'utilizzo di un ArrayList di "Coppia", classe creata appositamente per mantenere
    i dati inerenti alla coppia. Una volta caricate le diverse coppie dal file di input, viene mostrato all'utente un elenco di funzioni.
    La prima funzione richiede tre valori (a, b, s), che permettono successivamente di richiamare il metodo "find()". 
    Il metodo find() scorre tutta la lista per stampare ogni coppia che abbia il valore della chiave compreso tra a e b e la lunghezza
    della stringa minore o uguale a s. Il costo computazionale di questo metodo è O(n), dovendo scorrere tutti gli elementi della lista.
    La seconda funzione richiede un valore (c), che permette successivamente di richiamare il metodo "print()".
    Il metodo print() scorre tutta la lista per stamapre ogni coppia che abbia il valore della chiave maggiore o uguale a c.
    Il costo computazionale di questo metodo è O(n), dovendo scorrere tutti gli elementi della lista.
    Per concludere, la funzione che carica tutte le coppie dal file di input ha costo computazionale O(n).
    
    Il costo computazionale della soluzione è quindi O(n).

    Altre possibili implementazioni prevedevano l'utilizzo di MinHeap o HashMap, che avrebbero ridotto il costo computazionale di alcune
    operazioni, ma aumentato il costo dell'inserimento o di altre operazioni nei casi pessimi.